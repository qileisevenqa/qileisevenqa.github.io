(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{371:function(s,e,n){"use strict";n.r(e);var r=n(1),t=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var s=this,e=s.$createElement,n=s._self._c||e;return n("div",{staticClass:"content"},[n("h1",{attrs:{id:"如何在多种环境中运行cypress测试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何在多种环境中运行cypress测试","aria-hidden":"true"}},[s._v("#")]),s._v(" 如何在多种环境中运行cypress测试")]),s._v(" "),n("p",[s._v("cypress作为一种测试工具非常灵活，因为我们可以使用它来模拟HTTP响应，重新创建复杂的用户交互以及监视和响应网络请求。")]),s._v(" "),n("p",[s._v("另外，它是用JavaScript编写的！")]),s._v(" "),n("p",[s._v("对于某些人来说，这可能是优势，也可能不是优势。但是考虑到这是目前网络编程中最重要的语言。这意味着一种语言可以用于Web应用程序堆栈。并为您的测试解决方案提供支持，并实现与开发人员，测试人员甚至精通技术的利益相关者的无缝协作。")]),s._v(" "),n("p",[s._v("顺便提一下，这些并不是仅靠Cypress替代其他测试自动化工具的原因。我之前已经写过关于该主题的文章，并主张使用正确的工具来完成您的工作。但是，鉴于这是Cypress的博客文章，我将假设您已经做出了这个决定，并且想了解更多有关如何使用单个代码库在多个环境中进行测试的信息。因此，让我们继续前进。\n一个代码库来统治一切\n您很可能已经在一种环境中运行了测试，该环境专门用于与开发环境和面向客户的生产网站不同的测试或质量保证活动。")]),s._v(" "),n("p",[s._v("我还要假设您已经baseUrl在使用cypress.json它来配置运行测试的网站。")]),s._v(" "),n("p",[s._v("如果您不使用baseUrl Cypress提供的功能，那么它允许您指定与cy.visit()或cy.request()命令一起使用的前缀。而不是cy.visit(‘https://google.co.uk)例如输入。")]),s._v(" "),n("p",[s._v("随着baseUrl内设置cypress.json如下：")]),s._v(" "),n("p",[s._v("{\n“baseUrl”: “https://google.co.uk”\n}\n您只需要利用cy.visit(‘/’)即可复制之前获得的相同结果。太酷了吧？")]),s._v(" "),n("p",[s._v("但是，如果我们想在另一个环境上运行测试该怎么办？\nbaseUrl在您的主体内使用cypress.json就可以了。但是，如果您想根据需要切换环境并在没有人工干预和编辑的情况下运行测试该怎么办？")]),s._v(" "),n("p",[s._v("您真的不想在每当被询问或需要在另一个URL上运行集成测试时就进行配置更改。这不仅繁琐，而且意味着您的测试自动化功能不强大，缺乏最佳实践的使用，并且使维护工作变得更加困难。")]),s._v(" "),n("p",[s._v("幸运的是，Cypress为这个问题提供了一个解决方案，该解决方案使用起来非常优雅，并且在JavaScript的帮助下功能强大！")]),s._v(" "),n("p",[s._v("自定义配置\n如果您想在解决方案中互换使用变量，那么就需要使用多个自定义配置文件。这不仅使您可以将每个测试环境所需的选项区分开来。它还可以在每个解决方案之间进行快速切换，而无需进行复杂的配置更改或将解决方案传递给测试团队的新成员时可能会忘记的编辑。")]),s._v(" "),n("p",[s._v("我建议您做的是config在cypress文件夹中创建一个专用目录，并将自定义配置文件存储在其中。")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("cypress/config/qa.json\ncypress/config/testing.json\n")])])]),n("p",[s._v("它们中的baseUrl每一个都有自己的变量，我们将使用环境标志来调用每个变量，以便Cypress知道要使用哪个变量。")]),s._v(" "),n("p",[s._v("但是，我们正在超越自我。Cypress首先需要一种方法来理解这些新文件是配置文件。这可以通过使用下面的以下插件代码来实现。我之前曾写过关于插件的文章，作为生成测试数据的解决方案。但是出于多种原因，我们可以在Cypress中使用插件，它们是Cypress军械库中的佼佼者。")]),s._v(" "),n("p",[s._v("将以下内容粘贴到plugins/index.js文件中。")]),s._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[s._v("const path = require(“path”);\nconst fs = require(“fs-extra”);\n\nmodule.exports = (on, config) => {\n    \n    function getConfigurationByFile(file) {\n        const pathToConfigFile = path.resolve(“cypress/config”, `${file}.json`);\n\n        return fs.readJson(pathToConfigFile);\n    }\n    const file = config.env.configFile || “qa”;\n\n    return getConfigurationByFile(file);\n};\n\n")])])]),n("p",[s._v("简要说明上述操作。实质上是在通知Cypress config目录中的文件是有效的Cypress配置文件，如果在运行时在环境标志中传递了一个文件，则可以使用它吗？或者，如果未指定，则使用该qa.json文件。")]),s._v(" "),n("p",[s._v("注意：如果要使用上面的代码。确保同时安装了path模块和模块，fs并将它们保存到开发依赖项中。")]),s._v(" "),n("p",[s._v("如何在多种环境中运行Cypress测试\n凯文·塔克 （ Kevin Tuck） 于2020年9月8日")]),s._v(" "),n("p",[s._v("how_to_run_your_cypress_tests_in_multiple_environments\nCypress作为一种测试工具非常灵活，因为我们可以使用它来模拟HTTP响应，重新创建复杂的用户交互以及监视和响应网络请求。")]),s._v(" "),n("p",[s._v("另外，它是用JavaScript编写的！")]),s._v(" "),n("p",[s._v("对于某些人来说，这可能是优势，也可能不是优势。但是考虑到这是目前网络上的事实语言。这意味着一种语言可以用于Web应用程序堆栈。并为您的测试解决方案提供支持，并实现与开发人员，测试人员甚至精通技术的利益相关者的无缝协作。")]),s._v(" "),n("p",[s._v("是的，JavaScript\n顺便提一下，这些并不是仅靠Cypress替代其他测试自动化工具的原因。我之前已经写过关于该主题的文章，并主张使用正确的工具来完成您的工作。但是，鉴于这是Cypress的博客文章，我将假设您已经做出了这个决定，并且想了解更多有关如何使用单个代码库在多个环境中进行测试的信息。因此，让我们继续前进。")]),s._v(" "),n("p",[s._v("一个代码库来统治一切\n您很可能已经在一种环境中运行了测试，该环境专门用于与开发环境和面向客户的生产网站不同的测试或质量保证活动。")]),s._v(" "),n("p",[s._v("我还要假设您已经baseUrl在使用cypress.json它来配置运行测试的网站。")]),s._v(" "),n("p",[s._v("如果您不使用baseUrlCypress提供的功能，那么它允许您指定与cy.visit()或cy.request()命令一起使用的前缀。而不是cy.visit(‘https://google.co.uk)例如输入。")]),s._v(" "),n("p",[s._v("随着baseUrl内设置cypress.json如下：")]),s._v(" "),n("p",[s._v("{\n“baseUrl”: “https://google.co.uk”\n}\n您只需要利用cy.visit(‘/’)即可复制之前获得的相同结果。太酷了吧？")]),s._v(" "),n("p",[s._v("但是，如果我们想在另一个环境上运行测试该怎么办？\nbaseUrl在您的主体内使用cypress.json就可以了。但是，如果您想根据需要切换环境并在没有人工干预和编辑的情况下运行测试该怎么办？")]),s._v(" "),n("p",[s._v("您真的不想在每当被询问或需要在另一个URL上运行集成测试时就进行配置更改。这不仅繁琐，而且意味着您的测试自动化功能不强大，缺乏最佳实践的使用，并且使维护工作变得更加困难。")]),s._v(" "),n("p",[s._v("幸运的是，Cypress为这个问题提供了一个解决方案，该解决方案使用起来非常优雅，并且在JavaScript的帮助下功能强大！")]),s._v(" "),n("p",[s._v("自定义配置\n如果您想在解决方案中互换使用变量，那么就需要使用多个自定义配置文件。这不仅使您可以将每个测试环境所需的选项区分开来。它还可以在每个解决方案之间进行快速切换，而无需进行复杂的配置更改或将解决方案传递给测试团队的新成员时可能会忘记的编辑。")]),s._v(" "),n("p",[s._v("我建议您做的是config在cypress文件夹中创建一个专用目录，并将自定义配置文件存储在其中。")]),s._v(" "),n("p",[s._v("cypress/config/qa.json\ncypress/config/testing.json\n它们中的baseUrl每一个都有自己的变量，我们将使用环境标志来调用每个变量，以便Cypress知道要使用哪个变量。")]),s._v(" "),n("p",[s._v("但是，我们正在超越自我。Cypress首先需要一种方法来理解这些新文件是配置文件。这可以通过使用下面的以下插件代码来实现。我之前曾写过关于插件的文章，作为生成测试数据的解决方案。但是出于多种原因，我们可以在Cypress中使用插件，它们是Cypress军械库中的佼佼者。")]),s._v(" "),n("p",[s._v("将以下内容粘贴到plugins/index.js文件中。")]),s._v(" "),n("p",[s._v("const path = require(“path”);\nconst fs = require(“fs-extra”);")]),s._v(" "),n("p",[s._v("module.exports = (on, config) => {")]),s._v(" "),n("pre",[n("code",[s._v("function getConfigurationByFile(file) {\n    const pathToConfigFile = path.resolve(“cypress/config”, `${file}.json`);\n\n    return fs.readJson(pathToConfigFile);\n}\nconst file = config.env.configFile || “qa”;\n\nreturn getConfigurationByFile(file);\n")])]),s._v(" "),n("p",[s._v("};\n简要说明上述操作。实质上是在通知Cypress config目录中的文件是有效的Cypress配置文件，如果在运行时在环境标志中传递了一个文件，则可以使用它吗？或者，如果未指定，则使用该qa.json文件。")]),s._v(" "),n("p",[s._v("注意：如果要使用上面的代码。确保同时安装了path模块和模块，fs并将它们保存到开发依赖项中。")]),s._v(" "),n("p",[s._v("放在一起\n该过程的最后一步是使用所需的配置文件实际运行Cypress。为此，我建议scripts在您的package.json文件的部分中添加新行，这将消除您每次想要在环境之间进行切换时都需要写一条长命令的麻烦。")]),s._v(" "),n("p",[s._v("“scripts”: {\n“cy:open:qa”: “cypress open --env configFile=qa”,\n“cy:run:qa”: “cypress run --env configFile=qa”,\n}\n如果您使用的是VSCode。您需要做的就是单击命令以运行它，您正在新环境上进行测试！\n误。")]),s._v(" "),n("h3",{attrs:{id:"author"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#author","aria-hidden":"true"}},[s._v("#")]),s._v(" author")]),s._v(" "),n("p",[s._v("石头 磊哥 seven 随便叫")]),s._v(" "),n("h3",{attrs:{id:"company"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#company","aria-hidden":"true"}},[s._v("#")]),s._v(" company")]),s._v(" "),n("p",[s._v("thoughtworks")]),s._v(" "),n("p",[s._v("大家好，本人不才，目前依旧混迹于thoughtworks，做着一名看起来像全栈的QA，兴趣爱好前端，目前是thoughtworks 西安QA社区的leader，如果有兴趣分享话题，或者想加入tw，可以找我")]),s._v(" "),n("h3",{attrs:{id:"roles"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#roles","aria-hidden":"true"}},[s._v("#")]),s._v(" roles")]),s._v(" "),n("p",[s._v("QA（营生） dev（front-end dev 兴趣爱好）")]),s._v(" "),n("h3",{attrs:{id:"联系方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#联系方式","aria-hidden":"true"}},[s._v("#")]),s._v(" 联系方式")]),s._v(" "),n("p",[s._v("如果想转载或者高薪挖我 请直接联系我 哈哈")]),s._v(" "),n("h4",{attrs:{id:"wechat"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#wechat","aria-hidden":"true"}},[s._v("#")]),s._v(" wechat:")]),s._v(" "),n("p",[s._v("qileiwangnan")]),s._v(" "),n("h4",{attrs:{id:"email"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#email","aria-hidden":"true"}},[s._v("#")]),s._v(" email:")]),s._v(" "),n("p",[s._v("qileilove@gmail.com")])])}],!1,null,null,null);e.default=t.exports}}]);