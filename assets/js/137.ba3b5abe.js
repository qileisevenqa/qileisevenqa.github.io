(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{350:function(_,v,e){"use strict";e.r(v);var p=e(1),t=Object(p.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"测试自动化之路-selenium2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#测试自动化之路-selenium2","aria-hidden":"true"}},[_._v("#")]),_._v(" 测试自动化之路--selenium2")]),_._v(" "),e("p",[_._v("验收测试")]),_._v(" "),e("p",[_._v("进行这种类型的测试是为了确定产品的功能是否符合其要求。 这通常涉及客户的反馈或规格。")]),_._v(" "),e("p",[_._v("对于Web应用程序，可以通过模拟用户期望的行为直接使用Selenium来完成此测试的自动化。 可以通过记录/回放或通过本文档中介绍的不同受支持的语言来完成此模拟。 注意：验收测试是功能测试的子类型，某些人可能还会提到。")]),_._v(" "),e("p",[_._v("功能测试")]),_._v(" "),e("p",[_._v("进行这种类型的测试是为了确定产品的功能是否正常运行而没有问题。")]),_._v(" "),e("p",[_._v("这通常包括：测试以可用的方式（正确的重定向）正常运行，没有错误（404，异常…），")]),_._v(" "),e("p",[_._v("以易于访问的方式并符合其规格（请参见上面的验收测试）。")]),_._v(" "),e("p",[_._v("对于Web应用程序，可以通过模拟预期收益直接使用Selenium来完成此测试的自动化。")]),_._v(" "),e("p",[_._v("可以通过记录/回放或通过本文档中介绍的不同受支持的语言来完成此模拟。")]),_._v(" "),e("p",[_._v("性能测试")]),_._v(" "),e("p",[_._v("顾名思义，进行性能测试是为了衡量应用程序的性能。")]),_._v(" "),e("p",[_._v("性能测试有两种主要的子类型：")]),_._v(" "),e("p",[_._v("负载测试")]),_._v(" "),e("p",[_._v("进行了负载测试，以验证应用程序在不同定义的负载（通常是一次连接的特定数量的用户）下的运行状况。")]),_._v(" "),e("p",[_._v("压力测试")]),_._v(" "),e("p",[_._v("进行了压力测试，以验证应用程序在压力（或高于最大支持负载）下的运行状况。")]),_._v(" "),e("p",[_._v("通常，性能测试是通过执行一些Selenium书面测试来完成的，这些测试模拟了不同的用户使用Web应用程序的特定功能并检索了一些有意义的度量。")]),_._v(" "),e("p",[_._v("通常，这是由其他检索指标的工具完成的。 JMeter就是这样一种工具。")]),_._v(" "),e("p",[_._v("对于Web应用程序，要测量的详细信息包括吞吐量，延迟，数据丢失，单个组件加载时间…")]),_._v(" "),e("p",[_._v("注意1：所有浏览器的开发人员工具部分均具有“性能”标签（可通过按F12进行访问）")]),_._v(" "),e("p",[_._v("注2：是非功能测试的子类型，因为它通常是按系统而不是按功能/功能进行测量。")]),_._v(" "),e("p",[_._v("回归测试")]),_._v(" "),e("p",[_._v("该测试通常在更改，修复或添加功能之后进行。")]),_._v(" "),e("p",[_._v("为了确保所做的更改没有破坏任何现有功能，将再次执行一些已经执行的测试。")]),_._v(" "),e("p",[_._v("重新执行的测试集可以是全部或部分测试，并且可以包括几种不同的类型，具体取决于应用程序和开发团队。")]),_._v(" "),e("p",[_._v("测试驱动开发（TDD）")]),_._v(" "),e("p",[_._v("TDD本身不是测试类型，而是一种迭代开发方法，其中测试驱动功能的设计。")]),_._v(" "),e("p",[_._v("每个周期都从创建一组最终通过该功能的单元测试开始（这些单元测试将在首次执行时失败）。")]),_._v(" "),e("p",[_._v("此后，进行开发以使测试通过。 再次执行测试，开始另一个周期，此过程一直持续到所有测试通过为止。")]),_._v(" "),e("p",[_._v("这样做的目的是基于这样的事实，即缺陷越早发现成本越低，从而加快了应用程序的开发。")]),_._v(" "),e("p",[_._v("行为驱动开发（BDD）")]),_._v(" "),e("p",[_._v("BDD还是基于上述TDD的迭代开发方法，其目的是让所有各方参与到应用程序的开发中。")]),_._v(" "),e("p",[_._v("每个周期都从创建一些规范开始（应该失败）。 然后创建失败的单元测试（也应该失败），然后进行开发。")]),_._v(" "),e("p",[_._v("重复此循环，直到所有类型的测试通过。")]),_._v(" "),e("p",[_._v("为此，使用了规范语言。 各方都应该理解它，并且简单，标准和明确。 大多数工具都使用Gherkin作为这种语言。")]),_._v(" "),e("p",[_._v("目标是通过也针对潜在的接受错误，并使双方之间的通信更加顺畅，能够检测出比TDD甚至更多的错误。")]),_._v(" "),e("p",[_._v("当前有一组工具可用于编写规范并将其与代码功能（例如Cucumber或SpecFlow）匹配。")]),_._v(" "),e("p",[_._v("在Selenium之上构建了一组工具，可通过将BDD规范直接转换为可执行代码来使此过程更快。 其中一些是JBehave，Capybara和Robot Framework。")])])}],!1,null,null,null);v.default=t.exports}}]);