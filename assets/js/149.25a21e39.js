(window.webpackJsonp=window.webpackJsonp||[]).push([[149],{362:function(e,n,a){"use strict";a.r(n);var t=a(1),s=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{staticClass:"content"},[a("p",[e._v("在上一篇文章中，我们确实使用假设创建了一些检验来为我们生成输入日期。在那篇文章中，有一个验证类来验证密码。我在每个测试中都会检查API调用的回复。使用python进行API response验证并不困难。我解释一下。")]),e._v(" "),a("p",[e._v("假设我们有一个返回一些用户数据的API。例如，我可以使用ID调用函数getPerson并检索以下数据：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('{\n  "name": "testuser",\n  "age": 34,\n  "interest": "testing"\n}\n')])])]),a("p",[e._v("response是带有某些字段的json文件。名称至少应包含8个字符，并且不能超过12个字符。年龄是整数。系统中的用户必须年满21岁，因此18岁是无效的。interest的值是以下值之一：“testing”, “programming”, “agile”.")]),e._v(" "),a("p",[e._v("现在，我可以使用以下python代码检查所有值：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('class ReplyValidator(object):\n    def check_name(self, name):\n        if len(name) < 8:\n            return False\n        elif len(name) > 12:\n            return False\n        return True\n\n    def check_age(self, age):\n        if age < 21:\n            return False\n        return True\n    \n    def check_interest(self, interest):\n        if interest not in  ["testing", "programming", "agile"]:\n            return False\n        return True\n\nclass Reply():\n    def __init__(self, data):\n        self.name = data["name"]\n        self.age = data["age"]\n        self.interest = data["interest"]\n    \n    @property\n    def is_valid(self):\n        return all([\n            ReplyValidator().check_name(self.name), \n            ReplyValidator().check_street(self.street),\n            ReplyValidator().check_age(self.age),\n            ReplyValidator().check_interest(self.interest)\n            ])\n\n')])])]),a("p",[e._v("我也创建了一些单元测试来测试我们的验证类。我仍然是一名测试人员，所以我也测试自己的代码。")]),e._v(" "),a("p",[e._v("单元测试我自己的代码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('from line import Reply\n\ndef test_a_valid_reply():\n    reply_data = dict(name="testuser",\n                    street="testing street",\n                    age=34,\n                    interest="testing")\n\n    reply = Reply(reply_data)\n    assert reply.is_valid\n\ndef test_an_invalid_name():\n    reply_data = dict(name="test",\n                    street="testing street",\n                    age=34,\n                    interest="testing")\n\n    reply = Reply(reply_data)\n    assert not reply.is_valid\n\ndef test_an_invalid_age():\n    reply_data = dict(name="test",\n                    street="testing street",\n                    age=10,\n                    interest="testing")\n\n    reply = Reply(reply_data)\n    assert reply.is_valid\n')])])]),a("p",[e._v("在python中使用抽象方法\n代码很简单。但是，如果有额外的验证，则必须创建验证并添加额外的检查。您不必编写大量代码来检查它会不好吗？可以使用描述符技术编写验证类。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from abc import ABC, abstractmethod\n\nclass BaseValidator(ABC):\n    @abstractmethod\n    def validate(self, value):\n        pass\n\n    def __init__(self):\n        self.value = None\n\n    def __get__(self, obj, objtype):\n        return self.value\n    \n    def __set__(self,obj, value):\n        self.validate(value)\n        self.value = value\n")])])]),a("p",[e._v("首先，我们创建一个继承自ABC类的BaseValidator类。因此，我可以创建一个抽象方法。从此类继承的所有类都必须实现验证功能。")]),e._v(" "),a("p",[e._v("描述符可以绑定变量，例如python中的@property装饰器。我们可以创建一些数据类来保存值并检查该值是否有效。描述符的设置器首先调用一个函数来验证输入。BaseValidator的所有子类都必须实现此功能。现在界面已更改。如果验证失败，则会引发异常。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class OneOf(BaseValidator):\n    def __init__(self, values=list()):\n        self.values = values\n\n    def validate(self, value):\n        if not isinstance(value, str):\n            raise TypeError(f'{value} should be of type str')\n        if not(value in self.values):\n            raise ValueError(f'{value} should be one of {self.values}')\n\nclass String(BaseValidator):\n    def __init__(self, min_len = 8, max_len=12):\n        self.min_len = min_len\n        self.max_len = max_len\n\n    def validate(self, value):\n        if not isinstance(value, str):\n            raise TypeError(f'{value} should be of type str')\n        if len(value) < self.min_len:\n            raise ValueError(f'length of {value} should be at least {self.min_len}')\n        if len(value) > self.max_len:\n            raise ValueError(f'length of {value} should be not bigger than {self.max_len}')\n\nclass Integer(BaseValidator):\n    def __init__(self, minimum=21):\n        self.minimum = minimum\n    \n    def validate(self, value):\n        if not isinstance(value, int):\n            raise TypeError(f'{value} should be of type int')\n        if value < self.minimum:\n            raise ValueError(f'{value} should be at least {self.minimum}')\n")])])]),a("p",[e._v("我创建了3个示例类。String，Integer和OneOf类。String类具有最小和最大长度。验证器功能检查新值是否在最小和最大长度之间。")]),e._v(" "),a("p",[e._v("Integer类具有一个最小参数。验证功能检查新值是否大于此最小参数。")]),e._v(" "),a("p",[e._v("OneOf类很特殊。它接收可能的（字符串）值列表。验证功能检查新值是否为可能的值之一。")]),e._v(" "),a("p",[e._v("使用验证程序进行API回复验证\n现有代码现在应该更改。让我们以最小的变化尝试一下。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('class ReplyValidator(object):\n    name = String()\n    age = Integer()\n    interest = OneOf(["testing", "programming", "agile"])\n\nclass Reply():\n    def __init__(self, data):\n        self.name = data["name"]\n        self.age = data["age"]\n        self.interest = data["interest"]\n    \n    @property\n    def is_valid(self):\n        validator = ReplyValidator()\n        validator.name = self.name\n        validator.age = self.age\n        validator.interest = self.interest\n        return True\n\n')])])]),a("p",[e._v("两个测试用例需要更新。输入无效时，代码将引发异常。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('def test_an_invalid_name():\n    reply_data = dict(name="test",\n                    street="testing street",\n                    age=34,\n                    interest="testing")\n\n    reply = Reply(reply_data)\n    with pytest.raises(ValueError):\n        not reply.is_valid\n\ndef test_an_invalid_age():\n    reply_data = dict(name="testuser",\n                    street="testing street",\n                    age=10,\n                    interest="testing")\n\n    reply = Reply(reply_data)\n    with pytest.raises(ValueError):\n        reply.is_valid\n\n')])])]),a("p",[e._v("代码再次更改。不再需要is_valid方法。“框架”现在可以验证所有数据。如果验证失败，则会引发错误。因此我们的代码如下所示：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('class ReplyValidator(object):\n    name = String()\n    age = Integer()\n    interest = OneOf(["testing", "programming", "agile"])\n\nclass Reply():\n    def __init__(self, data):\n        self.validator = ReplyValidator()\n        self.validator.name = data["name"]\n        self.validator.age = data["age"]\n        self.validator.interest = data["interest"]\n')])])]),a("p",[e._v("该代码无需额外检查即可验证数据。现在可以使用Reply类验证API的response。将真实的API答复作为输入参数。使用python进行API response验证并不困难。这正是我要进行API测试所需要的")])])}],!1,null,null,null);n.default=s.exports}}]);