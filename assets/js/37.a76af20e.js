(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{250:function(e,a,r){"use strict";r.r(a);var t=r(1),n=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,a=e.$createElement,r=e._self._c||a;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"你真的会用thread-sheep-吗-md"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#你真的会用thread-sheep-吗-md","aria-hidden":"true"}},[e._v("#")]),e._v(" 你真的会用Thread.sheep()吗.md")]),e._v(" "),r("p",[e._v("使Web应用程序自动化可以优化工作，帮助最大程度地减少错误并使产品健壮。 当行为是可预测的时，自动化套件将是成功的。 如果不是这样，自动化中将有许多障碍需要谨慎处理。 有时，在使Web应用程序自动化时，我们可能会遇到NoSuchElementException异常，当找不到与之交互的元素时会抛出该异常。 当您实际上可以在网页上看到该元素时，这可能看起来很奇怪，但是在Selenium测试自动化过程中它消失了。")]),e._v(" "),r("p",[e._v("造成此异常的主要原因是，要交互的元素实际上存在于页面中，但加载并向用户显示自身需要时间。正如您可以想象的那样，这可能会成为自动化过程中的一个主要问题，并可能导致我们的脚本挂掉。这就是Selenium Java中的Thread.sleep()发挥作用的地方。在研究有效使用Java函数Thread.sleep()之前，让我们先了解关于Selenium中Thread.sleep()的基本知识。")]),e._v(" "),r("p",[e._v("thread.sleep()是什么?")]),e._v(" "),r("p",[e._v("为了使我们的脚本不那么古怪，我们必须添加等待，这将增加一些等待时间为一个元素或网页中的所有元素加载。这些等待的实现取决于自动化脚本中选择的等待类型。两个最常用的Selenium等待是-")]),e._v(" "),r("p",[e._v("Implicit wait 隐式等待——这种等待允许您暂停WebDriver一段特定的时间，直到WebDriver能够在web页面上找到所需的元素。")]),e._v(" "),r("p",[e._v("Explicit wait 显式等待——这种等待允许您基于预先设置的条件在特定时间内停止脚本的执行。")]),e._v(" "),r("p",[e._v("但是，在一些实例中，可以认为Thread.sleep()是更好的选择。")]),e._v(" "),r("p",[e._v("sleep()是一个静态Java方法，它将代码挂起一段特定的时间。它暂停执行，并帮助我们知道在暂停期间发生了什么。它接受以毫秒为单位指定的时间。此功能在调试网站或网页时特别有用。不要把这和上面提到的selenium混淆了。在下一节中，我们将深入研究Thread.sleep() Java和Selenium等待之间的区别。\n下面是Thread.sleep() Java-的语法")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("Thread.sleep(1000); \n")])])]),r("p",[e._v("在使用此方法时，您可能会遇到一个常见的异常—InterruptedException，它必须通过使用throw或try catch块来处理，如下所示—")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("try{\nThread.sleep(1000);\n}\ncatch(InterruptedException ie){\n}\n \nOr\n \npublic static void main(String args[]) throws InterruptedException{\nThread.sleep(1000);\n}\n")])])]),r("p",[e._v("在下一节中，我们将首先了解为什么以及如何在Java中使用Thread.sleep();让我们看看为什么在Selenium测试自动化中使用Thread.sleep() Java。")]),e._v(" "),r("p",[e._v("为什么在Selenium中使用Thread.sleep() ?")]),e._v(" "),r("p",[e._v("随着web应用程序越来越大，不同的应用程序完全加载需要不同的时间也就不足为奇了。sleep()在Selenium脚本中包含页面加载方面发挥了关键作用。使用像Thread.sleep() Java这样的函数使我们能够成功地运行自动化测试，而不会遇到脚本的任何故障。下面是我们为什么在Java- Selenium中使用Thread.sleep()的一些主要原因")]),e._v(" "),r("p",[e._v("处理动态元素:")]),e._v(" "),r("p",[e._v("有些时候，应用程序的网页有动态元素，很难预测其行为。例如，大多数电子商务网站有旋转木马/滑块设计，动态变化。我们可以明智地选择Thread.sleep()来等待几秒钟，而不是使用Selenium等待来检查web元素的可见性。")]),e._v(" "),r("p",[e._v("减少代码的复杂性:")]),e._v(" "),r("p",[e._v("在测试一个web页面时，有可能页面已经加载，执行已经转移到下一个步骤，但是没有足够的时间在页面中选择一个选项。在这种情况下，我们可以使用连贯等待来挂起时间，直到元素在页面中可见为止，也可以使用Thread.sleep()。选择后者更好，因为它涉及到添加一行代码，而不是在Selenium wait中添加5到6行代码。这种实现将避免不必要的代码复杂性。")]),e._v(" "),r("p",[e._v("我们可以在一段时间内使用Thread.sleep()来减少代码的复杂性，而不是使代码在下面的代码行中变得复杂。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('Wait<WebDriver> wait = new FluentWait<WebDriver>(driver)\n       .withTimeout(30, SECONDS)\n       .pollingEvery(5, SECONDS)\n       .ignoring(NoSuchElementException.class);\n \n   WebElement element = wait.until(new Function<WebDriver, WebElement>() {\n     public WebElement apply(WebDriver driver) {\n       return driver.findElement(By.id("username"));\n     }\n   });\n\n')])])]),r("p",[e._v("测试第三方系统:")]),e._v(" "),r("p",[e._v("在测试与第三方组件交互的web页面时，我们可能不知道它是如何设计的。我们可能不知道一个web元素需要多长时间才能在网页中可见。因此，预测处理web元素的条件似乎很复杂，有时甚至是不可能的。在这种情况下，我们可以通过使用Thread.sleep() Java方法来延迟执行时间。")]),e._v(" "),r("p",[e._v("处理AJAX调用:")]),e._v(" "),r("p",[e._v("AJAX(异步JavaScript和XML)是一种高级通信技术，网页在不影响网页当前状态的情况下向服务器请求某些信息。sleep()将是处理web页面中的AJAX调用的最佳选择之一，因为测试将等待服务器响应一段时间。在某些网页上，你可以看到板球或足球比赛的现场比分。在这里，分数以特定的时间间隔更新，而网页中所有其他元素保持不变。这是一个AJAX调用的示例，在执行测试时，如何使用Thread.sleep()处理它将是一个更好的选项。")]),e._v(" "),r("p",[e._v("使用Thread.Sleep() Java实现Selenium测试自动化")]),e._v(" "),r("p",[e._v("现在您已经理解了为什么在Selenium Java中Thread.sleep()是一个好的选择，本节将向您展示如何在Selenium测试自动化中实现这个功能。为了展示它的实现，我们使用了一个网站的例子——easemytrip.com。在这里，我们将向您展示一个实例用户选择“From”和“To”目的地以及旅行日期。")]),e._v(" "),r("p",[e._v("正如预期的那样，easemytrip.com将花费一些时间来加载相关的航班信息。为了避免在我们的脚本中出现这种延迟，我们将在用户单击' Search '时立即停止线程执行。一旦我们这样做了，您就会看到脚本将顺利运行，而不会抛出异常或错误。")]),e._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('import java.util.concurrent.TimeUnit;\n\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport com.gargoylesoftware.htmlunit.javascript.background.JavaScriptExecutor;\n\npublic class ThreadWait {\n\n    public static void main(String[] args) throws InterruptedException {\n        // TODO Auto-generated method stub\n        \n        //setting the driver executable\n        System.setProperty("webdriver.chrome.driver", ".\\\\Driver\\\\chromedriver.exe");\n        \n        //Initiating your chromedriver\n        WebDriver driver=new ChromeDriver();\n        \n        driver.manage().window().maximize();\n        \n        \n        driver.get("https://www.easemytrip.com/");\n        \n        driver.findElement(By.id("FromSector_show")).sendKeys("Delhi", Keys.ENTER);\n        driver.findElement(By.id("Editbox13_show")).sendKeys("Mumbai", Keys.ENTER);\n        driver.findElement(By.id("ddate")).click();\n        driver.findElement(By.id("snd_4_08/08/2019")).click();\n        driver.findElement(By.className("src_btn")).click();\n        Thread.sleep(5000);\n        driver.findElement(By.xpath("//button[text()=\'Book Now\']")).click();    \n\n    }\n\n}\n')])])]),r("p",[e._v("让我们考虑另一个例子。如果我们在easemytrip.com上有另一个网页，它需要的加载时间少于或多于指定的时间，会怎么样?当涉及到Selenium Java中的Thread.sleep()时，根本没有考虑花费在查找元素上的时间，因为这是一个静态等待。Selenium WebDriver将别无选择，只能等待指定的时间，而不管元素是否已经被定位。这就是为什么我们不喜欢在自动化脚本中多次使用Thread.sleep()的原因。")]),e._v(" "),r("p",[e._v("Thread.sleep() Java的替代方案")]),e._v(" "),r("p",[e._v("人们经常问‘使用Thread.sleep()是一个好习惯吗?或者“我可以用什么来代替Thread.sleep()?”")]),e._v(" "),r("p",[e._v("当然，Java已经提供了Thread.sleep()，但是在自动化脚本中使用时，它通常被认为是不稳定的。理想情况下，不建议在脚本中使用Thread.sleep()，因为它可能会增加测试执行时间(如上一节所述)。虽然使用第三方接口和AJAX调用执行测试看起来总是很复杂，但如果明智地使用适当的等待(如Thread.sleep())来处理，就可以轻松执行，获得高精度的结果。")]),e._v(" "),r("p",[e._v("如果您的情况不是这样，那么最好使用其他Selenium等待，如隐式等待、显式等待或流畅等待。您可以参考本教程了解如何在Selenium中使用显式和流畅等待。")]),e._v(" "),r("p",[e._v("Thread.sleep()和wait之间的区别")]),e._v(" "),r("p",[e._v("等待将在指定的时间内完全停止执行线程。另一方面，Thread.sleep()暂停执行并帮助我们知道发生了什么。但这还不是全部。下面列出了Thread.sleep() Java方法与Selenium wait -之间的关键区别")]),e._v(" "),r("p",[e._v("Sleep是一个静态方法，属于Java的“Thread”类。另一方面，隐式、显式和流畅的Selenium等待在本质上是动态的。")]),e._v(" "),r("p",[e._v("如果你使用线程。当执行Selenium测试自动化时，它将在脚本中指定的时间内停止脚本的执行，而不管web页面上的元素是否已经被找到。Selenium等待不等待完整的时间。如果WebDriver能够在指定的时间期限之前找到元素，它就会转到下一行代码。这有助于大大减少脚本执行的总体时间。")]),e._v(" "),r("p",[e._v("等待通常是全局应用的，也就是说，我们只需要在脚本中写入一次，它适用于整个WebDriver实例中指定的所有web元素。对于Thread.sleep()则不是这样，在这里您需要为每个web元素重新编写它。这使得等待在Selenium Java中比Thread.sleep()更好。")]),e._v(" "),r("p",[e._v("Thread.sleep()和Selenium setSpeed()的区别")]),e._v(" "),r("p",[e._v("正如我们在上面看到的如何在Java中使用Thread.sleep()，我们清楚地知道它是用来延迟代码执行的。setSpeed()具有类似的作用，也用于延迟过度执行。然而，这两种功能是不同的。")]),e._v(" "),r("p",[e._v("Selenium setSpeed()主要用于设置特定的执行速度。在Selenium中运行脚本时，默认情况下没有延迟。在setSpeed()的帮助下，我们可以设置每次在Selenium脚本中执行时的延迟长度(以毫秒为单位)。")]),e._v(" "),r("p",[e._v("简单地说，Thread.sleep()让WebDriver在执行之前等待特定的时间，而且这种情况只会发生一次。另一方面，setSpeed()设置所需的执行速度，或在每个操作之前将执行延迟指定的时间。\nsetSpeed:设置执行速度(例如，设置每次selenium操作后延迟的毫秒长度)。默认情况下，没有这样的延迟，也就是说，延迟是0毫秒。")]),e._v(" "),r("p",[e._v("线程。sleep:它使当前线程挂起执行一段指定的时间。")]),e._v(" "),r("p",[e._v("因此，它们之间的主要区别是setSpeed设置了一个速度，而将在每个selenium操作发生之前应用延迟时间。但是一个thread.sleep()只会等待一次。所以，如果我们有3个selenium操作写在下面:")]),e._v(" "),r("p",[e._v('Opeartion 1\nOpeartion 2\nOpeartion 3\n我们想为每一个设置一个延迟时间2000，定义一次setSpeed()方法将完成如下任务:\nselenium.setSpeed("2000");\nOpeartion 1\nOpeartion 2\nOpeartion 3\n但如果我们使用Thread.sleep()，它就会像下面这样:\nThread.sleep(2000);\nOpeartion 1\nThread.sleep(2000);\nOpeartion 2\nThread.sleep(2000);\nOpeartion 3')]),e._v(" "),r("p",[e._v("结论")]),e._v(" "),r("p",[e._v("我们希望通过阅读本文，您已经学会了使用Thread.sleep() Java方法的有效方法。在进行web应用程序调试时，Thread.sleep() Java是一种有用的方法，甚至可以通过一个在线Selenium网格来实现，用于像LambdaTest这样的跨浏览器测试平台。")]),e._v(" "),r("p",[e._v("如果您在其他情况下发现了有效实现此方法的更好方法，请告诉我们。此外，如果你有任何问题，请通过下面的评论区联系我们。")]),e._v(" "),r("h3",{attrs:{id:"author"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#author","aria-hidden":"true"}},[e._v("#")]),e._v(" author")]),e._v(" "),r("p",[e._v("石头 磊哥 seven 随便叫")]),e._v(" "),r("h3",{attrs:{id:"company"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#company","aria-hidden":"true"}},[e._v("#")]),e._v(" company")]),e._v(" "),r("p",[e._v("thoughtworks")]),e._v(" "),r("p",[e._v("大家好，本人不才，目前依旧混迹于thoughtworks，做着一名看起来像全栈的QA，兴趣爱好前端，目前是thoughtworks 西安QA社区的leader，如果有兴趣分享话题，或者想加入tw，可以找我")]),e._v(" "),r("h3",{attrs:{id:"roles"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#roles","aria-hidden":"true"}},[e._v("#")]),e._v(" roles")]),e._v(" "),r("p",[e._v("QA（营生） dev（front-end dev 兴趣爱好）")]),e._v(" "),r("h3",{attrs:{id:"联系方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#联系方式","aria-hidden":"true"}},[e._v("#")]),e._v(" 联系方式")]),e._v(" "),r("p",[e._v("如果想转载或者高薪挖我 请直接联系我 哈哈")]),e._v(" "),r("h4",{attrs:{id:"wechat"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wechat","aria-hidden":"true"}},[e._v("#")]),e._v(" wechat:")]),e._v(" "),r("p",[e._v("qileiwangnan")]),e._v(" "),r("h4",{attrs:{id:"email"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#email","aria-hidden":"true"}},[e._v("#")]),e._v(" email:")]),e._v(" "),r("p",[e._v("qileilove@gmail.com")])])}],!1,null,null,null);a.default=n.exports}}]);